< 09 메모리 모델과 이름공간(namespace) >

( 09.1 분할 컴파일 )

C++는 프로그램을 구성하는 함수들을 나누어서 만들고, 링킹하는것을 허용한다.  만약 하나의 파일만 수정해야 한다면 그 파일만 다시 수정후 컴파일 하고 링킹하는 식으로 분할 컴파일이 가능하여서 대용량 프로그램을 만드는데 유리하다.

즉 대부분은 ide는 소스들의 수정시간을 추척하여서 변경된 소스들만 다시 컴파일하여서 링킹한다.

C++에서는 #include 라는 전처리기를 사용하여 헤더파일등을 적용할 수 있다.

이러한 기능을 제공하므로, 이런식으로 클래스, 함수코드 등을 헤더파일에 만들어서 하나의 패키지를 구성할 수 있다.  이것은 OOP의 특성에 매우 부합하는 점이다.

* 헤더파일에 넣는 것들
    함수원형    #define, const 정의하는 기호 상수    구조체 선언    클래스 선언    템플릿 선언    인라인 함수 등을 넣는다.    

* #include
    #include 에서  <>으로 묶여있으면 컴파일러는 표준헤더파일에서 찾고, " "으로 묶여있으면 소스디렉토리에서 찾게된다. (사용자가 만든 헤더파일을 include 할땐 " "을 이용한다.)



( 09.2 기억존속시간(namespace), 사용범위, 링크 )

C++는 네가지 유형으로 데이터를 저장한다.

{
    * 자동 기억 존속 시간
       
       함수나 블록안에 들어갈때 생성되고, 해당 함수나 블록을 떠날 때 해제된다.
        
       이렇게 자동적으로 생성/해제되는 것들을 "자동변수(지역변수)"라고 부른다.

        
        * 자동변수

        함수의 경우    아래의 함수가 있다고 가정하자.
            void print(int x)                      <--- 여기에서 인자로 들어온 x는 복사되어 들어온것이기에 변화가 되어도 메인함수에서의 x에는 아무런 영향을 끼치지 않는다.
            {                                           *** 여기에서의 x(인수)는 함수안에서만 유호하다.
                cout<< x <<endl;
            }


        블록의 경우
                int x;
            {
                int x;        <---- 여기서 선언된 x는 블록안에서만 유효하다.
            }

        

        * 자동변수와 스택
            
            새로 생기는 데이터는 먼저 생성된 데이터위에 쌓이고, 프로그램이 종료되면 데이터는 스택에서 제거된다. (자동변수도 마찬가지로 스택구조로 실행됨)

            프로그램은 두개의 포인터를 이용하여서 스택을 관리한다.   한포인터는 스택의 바닥(시작위치)의 주소를 가르키고, 다른 한 포인터는 다음 번 데이터를 저장할 (스택의 꼭대기) 빈곳의 주소를 가르킨다.

            
            (함수가 실행될때 어떻게 스택에 자동변수가 저장되고 해제되는지)
                
                1. 일단 스택에 한 포인터는 바닥을 가르키고, 다른 포인터는 빈 포인터를 가르키고 있다.

                2. 이후 함수가 실행되면 함수의 파라미터로 들어온 값들이 스택에 저장된다. 이후 다시 포인터는 움직여서 다음 빈 주소를 가르킨다.
                    
                    Ex) void print(int x, short y) {}                 
                        
                        위의 함수에서의 인자를 보면 int형 short형 두개가 들어오므로,  스택에 4,2 byte만큼의 메모리가 할당되고 스택에 저장된다.
                
                3. 함수종료 후, 포인터는 다시 처음 가르키던 위치로 돌아간다.(데이터들이 들어오기전 꼭대기를 가르킴)   *** 스택의 들어왔던 데이터는 사라지지 않음. 단, 포인터가 데이터가 들어가기전으로 돌아갔으므로
                                                                                                                   이후 다시 데이터가 스택으로 들어오면 다른값이 저장되므로 문제가 없다. (P.575)
          
          

                    
 
    * 정적 기억 존속 시간
        함수정의 바깥에서 정의된 변수 (main()함수 밖... ) 또는 static을 사용하여 정의된 변수등이 갖는것으로, 프로그램이 실행되는 전체시간에서 존속한다.
        

        * 정적변수          정적변수는 프로그램이 실행되는 전체시간동안 존속한다.  따라서 정적변수를 관리하는데 스택같은 장치가 필요가없다. 대신, 모든 정적변수를 수용할 수있는 메모리 블럭을 대입해준다.
        
            *** 정적변수가 초기화되지 않았다면 모든 비트가 0으로 세팅된다.   이것을 제로-초기화 (Zero-initialized)라고 한다.  <-- 일반변수와 다른점임. default initialization 이 있음

            (*** 정적변수의 종류 ***)

            1. 함수안에 있는 static
                
                void func()
                {
                    static int a = 0;     <--- *** 여기에 선언된 정적변수는 함수안에서만 사용할 수 있다. 단, 함수가 끝나도 메모리에 정적변수로써 값은 저장되어 있다.   
                    a ++ ;                <--- *** 즉, 다음에 이 함수안에서 a에 접근하면 1, 2, 3, 4, 5 이런식으로 흘러가게 된다. (값이 계속 저장되어있으므로)
                }
            

            2. 함수 외부에 static

                static int b = 1;         <--- *** 함수 외부의 정적변수는 이 파일에서는 모두 이용할 수 있다.

                int main()
                { ... }


            3. global
                
                전역변수는 main()함수 외부의 정의된 변수를 말한다.

                int g_value = 2;         <--- *** 이파일말고도 다른 파일에서도 접근할 수 있으며 끝까지 유지되는 변수이다.        (다른 파일에서 이용하게 될 경우 estern int g_value 이런식으로 선언후 사용한다.  (헷갈림을 방지하게위해 global인것을 알리기 위해)
                )

                int main()
                {}
                
                                    

    * 쓰레드 존속 시간
    
    * 동적 기억 존속 시간
        new를 통한 동적할당된 메모리는 delete 또는 프로그램이 종료할 때 까지 존속한다.
}





    
        









< 11 클래스의 활용 >

( 11.1 연산자 오버로딩 )

opereator <-- 연산자 오버로딩을 하기 위한 연산자 함수      형식은   operator op () 

operator op ()는  앞에 객체를 임시적으로 사용하고 그안의 멤버 메소드로 op를 가져와서 사용한다.

Ex)  class A 안에  operator +() 이 오버로딩 되어있다고 가정하고 
     A a;
     B b;
 
     a+b; 를 하게되면    <--- *** a.operator + (b); 와 같이 작동한다. (a에서 operator+을 호출하고 인자로 b를 넣는 것처럼)





( 11.2 연산자오버로딩 예제 )

Ex)
     class A
    {
     public:
        int x;

       A operator + (A& a)                    <---- 이런식으로 클래스안에 operator오버로딩이 되어있을 경우 A&가 아닌 A로 리턴형을 사용해야한다 왜냐하면 이 예제에서는 result라는 클래스가 {} 안에서
       {                                            지역변수로 만들어지기 때문에 참조로보내면 지역변수므로 사라진후 참조가 불가능하기 때문이다.
            A result; 
                                                    *** 지역변수는 참조를 하면 안된다.
            result = x + a.x ;                      (부른객체의 x + a의 x)
            
            return result;
       }
    }




    연산자 오버로딩은 객체를 리턴할시 연쇄적으로 이용할 수 있다. chainning

    A t1,t2,t3;
       
    t1+t2+t3; 도 가능하다.   연쇄적으로 operator을 호출 할 수 있다.  t1+t2에서 A클래스인 객체를 리턴하므로 t1+t2리턴한객체에서 다시 operator을 호출하고 ... 연쇄적으로 가능



    연산자 오버로딩을 하게될 시  적어도 하나의 피연산자는 사용자 정의형 데이터형이어야 한다. (둘다 일반 데이터형이라면 오버로딩을 하지않고 그냥 일반 연산자 연산을 하게될테니까..)

    연산자의 우선순위 또한 변경할 수 없다.  + 보단 x 먼저..





( 11.3 프렌드의 도입 )

    프렌드는 프렌드함수, 프렌드 클래스, 프렌드 멤버함수의 형태로 쓰인다.

    함수를 어떤 클래스의 프렌드로 만들면, 그함수는 프렌드한 클래스와의 관계가 클래스와 클래스의멤버함수와의 관계와 같게된다. (*** 즉, private의 값에도 접근이 가능하게 된다.)

    특히 어떤 클래스의 이항연산자를 오버로딩을 할경우, friend를 만들 필요성이 많이 생긴다.

Ex) class A
    {
    private:
        int x;

    public:
        A operator *(double mult)
        {
            A result;
            result = x * mult;      (호출한 객체의 x값에 mult를 곱한다)

            return result;
        }
    }

    int main()
    {
        A a;

        a*3;    <--- 문제가 되지않는다.

        3*a;    <--- *** 이경우 문제가 된다.  3.operator *(a);는 불가능하기 때문이다. 3은객체가아니기때문     이렇게 연산을하는 자료형이 서로 다를 경우 문제점이 발생한다.  모든사람들에게 3*a대신 a*3이라고 쓰라고 할수도 없는 노릇이다

        return 0;
    }




* 프렌드 생성하기               위와같은 3*a 문제를 해결하기위해서 friend를 사용한다. friend가 하는기능은 여기서 크게 2가지이다.

    class A
    {
    private:
        int x;

    public:
        friend A operator *(double mult, A& a)      *** friend의 기능    1. operator *() 함수는 클래스안에 선언됬지만 "멤버함수가 아니라고 알린다."    2. operator *()를 멤버함수와 동등한 권한을 부여한다.
        {                                                                      
            A result;                                   friend를 붙여준 연산자오버로딩은 A:: 이런식의 namespace를 사용하지 않는다.(더이상 멤버함수가 아니기 때문)
            result = mult * a.x;

            return result;
        }
    }

    int main()
    {
        A a;
        A result;

        result = 2.7 * a;    <--- *** 이것이 가능하게 된다.  2.7.operator*()이 아닌  "일반함수"처럼 operator*(2.7, a); 실행되기 때문이다

        return 0;
    }




* 프렌드: << 연산자 오버로딩

    *** ostream 클래스안에는 cout객체가 있다. + ostream 클래스는 <<연산자를 오버로딩하여서 출력도구로 변환시킨다.

    즉, <<을 오버로딩하기위해서는 사용자정의클래스를 cout이 인식하도록  사용자정의클래스에 cout 사용법을 알려주는갓이 바람직한 방법이다.

    ***  <<연산자 오버로딩을 할때에도 마찬가지로 friend를 사용해야한다.  예시를 보면 이해하기 쉽다.

    Ex)  a라는 객체가 있다고 가정하자.  (a에는 <<가 오버로딩 되어있다)

        cout << a;     <--- *** 이것은 앞에서 본것처럼 cout.operator <<(a); 가 되버린다.  cout객체안에는 operator << 오버로딩이 없으므로 코드가 실행되지 않는다.  그렇다고해서 a << cout을 할수도 없지 않은가?

    *** 즉, cout << 에서도 friend를 사용하여서 멤버함수가아닌 일반함수로 사용해야 한다는 의미이다.                        
    
    
    즉, 프렌드를 사용하여 구현하면 이렇게 표현할 수 있다.
    class A
    {
    private:
        int x;
    
    public:
        friend ostream& operator << (ostream &os, A& a)            <--- *** 즉, operator << (cout, a); 처럼 이용된다는 것이다.   (일반함수이면서 + private에도 접근가능함)
        {                                                            operator << (ostream &os, A& a)  & 참조를 사용하는 이유는 os받고 또다시 os를 리턴하기 때문이다. 만약 os로 받고 다시 리턴한다면 복사값(지역변수)
            cout << a.x;                                             므로 다음에 참조가 되지않고 사라저버리기 때문이다.
            return os;                                      <--- *** ostream 객체를 참조로 리턴하기 때문에, cout << a << a ... <<을 연속적으로 호출할 수 있게된다.
        }                                                            계속해서 cout을 리턴하므로 연쇄적으로 호출이 가능함.
    }





( 11.4 오버로딩 연산자: 멤버함수와 멤버함수가 아닌 함수 )

    friend 멤버함수의 권한을 갖긴하나, 멤버함수가 아님.

    일반 operator overloading  멤버함수의 권한을 갖으며  멤버함수임.





( 11.6 자동변환과 클래스의 데이터형 변환 )

    * 아래의 예들은 대입되는 변수의 자료형에 맞게 들어가는 수의 자료형이 바뀐다.
    long l = 12;
    double d = 3;
    int i = 3.14;      <--- 단, 이런식으로 절삭이 일어날 수 있는 문제점이 있다.

    * 그러나 아래의 예와 같이 호환되지 않는 데이터형은 자동으로 변환하지 않는다.
    int *ptr = 10;     <--- 포인터는 주소를 받아야하므로, 10 정수를 받지 못한다.
                            int *ptr = (int*)10; 이런식으로 포인터로 명시적 형변환을 하여 대입을 할 순 있다.    (10이란 주소에 데이터가 있다면 읽어올 순 있음)  명시적 형변환은 자동으로 형변환이 안될 시 사용함



* 클래스의 자동 형변환 (묵시적 형변환)

    C++에서 하나의 매개변수만 취하는 클래스의 경우 자동적인 형변환이 가능합니다.

    class A
    {
    public:
        int x;

        A(int x_in)          <-- 하나의 매개변수만이 사용되는 생성자    << *** 변환생성자로 동작합니다. >>
            :x(x_in)
            {}
    }

    int main()
    {
        *** 원래같았다면 a.x = 3;   a.x = 14; 와 같이 바꾸어주어야하는데  클래스내의 매개변수가 "1개"라면 자동 형변환이 일어나   a(객체) = 3(정수) 의 대입이 가능하게 되는 것입니다. (변환생성자를 통해서 이루어짐)
        
        A a = 3;
        cout << a.x << endl;            <--- 3

        a = 14;
        cout << a.x << endl;            <--- 14 
    
        return 0;
    }



* Explicit을 통해 자동형변환 막기

    이러한 매개변수가 1개일 경우 변환생성자를 통해 자동 형변환이 되는 것을 막기 위해서 explicit을 사용할 수 있습니다.

    explicit A(int x_in)       <--- 이런식으로 변환생성자 앞에 explicit을 통해 막아주게 되면        A a = 13; 와 같은 자동적 형변환이 불가능하게 됩니다.
            :x(x_in)
            {}



* 변환 연산자     이번에는 객체 ---> 데이터형으로 변환하는 방법입니다.

    A a(5);

    int num = a;     <----는 컴파일에러가 발생합니다.   자동형변환이 불가능한  일반자로형 = 객체    일반자료형에 객체를 대입하기 때문입니다.

    이때 변환함수를 사용합니다.
    
    (변환함수)
    
    1. 변환함수는 메소드여야 합니다. (멤버함수여야함)                 operator typename()
    2. 변환함수는 리턴형이 없습니다.                                {
    3. 변환함수는 매개변수를 갖지 않습니다.                              return x;    // 형변환할 것                          
                                                                  }                                
                                
    class A
    {
    public:
        int x;

        A(int x_in)
        :x(x_in)
        {}

        operator int()    <--- *** 이때 이런식응로 변환함수를 작성하게 되면   일반자료형에 객체를 넣을 수 있습니다. (함수가 명시적 형변환을 해주게 됨)
        {
            return x;
        }
    }

    int main()
    {
        A a(5);
        
        int num = int(a);    <--- operator int()을 이용하여서 int형변수에 객체를 대입하는 것이 가능하다.          강제형변환

        int num = a;         <--- 이런식으로 int()를 생략하고 대입할 수 있다.    *** 이 경우 컴파일러가 알아서 변환함수가 있나 찾아보고 호출한다.

        return 0;
    }


    그런데 여기서도 실수의 여지가 있을 수 있다.  왜냐하면 변환함수의 경우에도 자동형변환이 일어날 수 있다는 점 때문이다.     원치않게 int num = a;와 같이 형변환이 자동으로 일어나 에러가 발생할 수 있기 때문이다.

    따라서  변환함수에도 C++는  explicit을 허용한다.



* Explicit 변환 함수
    
    class A
    {
        ...
        explicit operator int()    // *** explicit을 변환함수에 사용하게되면,  int num = a; 는 불가능해지고   int num = int(a); 이런식으로 명시적으로 코딩을 해주도록 된다.
        {
            return x;
        }    
    }

    int main()
    {
        A a(3);

        int num1 = a;       (x)  불가능

        int num2 = int(a);  (o) 가능

        return 0;
    }




