











< 04 복합 데이터형 >

( 04.1 배열 )

배열은 데이터형이 같은 여러개의 값을 연속적으로 저장하는 데이터 구조이다.  컴퓨터는 이 원소들을 메모리에 "연속적"으로 배치한다.

배열 선언의 일반적인 형식      typeName arrayName [arraysize];   ***  arraysize는 컴파일타임에 결정되는 값이어야 한다. Ex) 10, const 상수 등...

배열은 인덱싱을 통해서 각각의 원소에 한번에 접근 할 수 있다는 장점이 있다.



( 04.2 문자열 )

* C 스타일 문자열
    
    *** 모든문자열의 마지막 문자는 반드시 '\0' null character여야 한다.   '\0'은 ASCII코드가 0인 문자이다.     '\0'은 문자열의 끝을 표시한다.  (맨뒤에 '\0'이 있어야만 문자열이다.)
                                                                                                           cout등 많은 문자열 처리함수가 널문자를 만날때까지 문자열을 처리하는것으로 설정이 많이 되어있기 때문

    char ch1[] = "hello";      <--- *** " "로 초기화를 하면  " "으로 싸진 문자들을 순차적으로 배열에 넣고 마지막에 '\0'까지 알아서 넣어준다.

    char ch2[100] = "hello";   <--- *** 만약 " "로 싸여진 문자들보다 배열의 크기가 클 경우, 남은 배열의 원소에 모두 '\0'을 넣는다.   h e l l o \0 \0 \0 \0 \0 \0 \0 \0 .....

    "s"  vs  's'               <--- *** " "은 문자열이기에 '\0'을 묵시적으로 뒤에 넣어주나,  ' '은 문자이기에 '\0'가 들어가지 않는다.  "s"는 크기가 2bytes   's'는 크기가 1byte만 차지하게 된다.
                                    *** 또한 " "는 내부적으로 주소를 나타내므로, char[] 배열로 받아주어야 한다.
    
    strlen()                   <--- *** strlen()은 ()안의 문자열에서 문자의 개수를 리턴한다. ( '\0'의 개수는 세지않고 리턴함 )

    *** cin의 주의점            <--- *** 키보드를 통해 문자를 입력받을 경우 '\0'을 입력받지 못하기 때문에 빈칸,탭,엔터등이 들어오게 되면 문자열이 끝나는 것으로 간주하는 특성이 있다.  따라서 cin만으로는 빈칸을 받을 수 없다.
                                    *** cin은 키보드로 입력받다가 빈칸,텝,엔터등을 만나면 읽는것을 종료한뒤 뒤에 '\0'을 붙여서 저장한다. ******* cin은 개행문자를 남긴다. ******
                                    *** cin은 입력을 받은뒤에 cin객체를 다시 리턴한다 ---> 연쇄적인 호출이 가능함

* 한번에 행 단위로 입력받기

    * getline()

        cin.getline(char_arr,count,);    <--- *** cin.getline()은 입력받을 배열과 문자를 몇개까지 받을지를 인자로 받는다 + 로 마지막에 어떤 문자를 개행문자로 할지까지 정할 수 있다. (default '\n')
                                         <--- *** 즉, getline()은 count-1개의 문자를 받게되거나, '\n'을 만나거나 둘중의 하나의 조건이 완료되면 읽어들이기를 종료하고 '\0'을 뒤에 넣은뒤 저장한다.
                                         <--- *** 또한 getline()은 개행문자를 만나서 종료될 경우, 개행문자를 읽어들인뒤 버려서 없앤다.
        

    * get()
        
        cin.get(char_arr,count);         <--- *** getline과 똑같이 동작하나  하나의 점이 다르다. 개행문자를 만나서 종료될 경우 개행문자는 놔두고 그 앞까지만 저장한다는 점이다.
        cin.get()                        <--- *** 따라서 그 개행문자를 지우기 위해서 cin.get()을 사용하기도 한다. cin.get()의 기능은 무엇이던간에 첫 문자를 읽는 기능을 한다.


    * 연쇄호출

        getline(), get() 둘다 cin객체를 리턴하므로,  E)  cin.get(name1,20).get(name2,20);   이런식으로 연쇄적으로 받을 수 있다.




( 04.3 string 클래스 )

* string이 C 스타일 문자열과 다른 점                  <<< 일단, string 은 마지막에 '\0'문자를 넣지 않는다. >>>
    
    string str1;
    string str2;

    str1=str2;     <--- 이런식으로 스트링에 스트링을 대입해 줄 수 있다.  (c스타일은 불가)

    str1+=str2;    <--- 이런식으로 string은 +-연산이 가능하다.


* string을 통해 한 행 단위로 입력 받는법

    getline(cin,str);    getline(입력을 찾을곳, 입력을 저장할 string);         <--- #include<string>




( 04.4 구조체 )

구조체란 >>> 여러관련된 정보들을 하나로 모아서 저장할 수 있는 구조를 말한다.   Ex) 자동차라고 한다면  차체, 바퀴, 창문, 엔진 ..     하나의 구조체안에 여러가지의 데이터를 저장할 수 있으므로, 배열보다 융통성이 크다.

*** 구조체도 같은 구조체를 통해서 만들어진 객체끼리는 대입이 가능하다.

struct st
{
    int x;
    double y;
};

int main()
{
    st s1{2, 3.14};
    st s2{1, 5.3};

    s2 = s1;     <--- 이런식으로 같은 struct를 통해 만들어진 객체끼리는 대입도 가능하다.

    return 0;
}



( 04.5 공용체 )

공용체(union)은 서로다른 데이터를 한번에 한가지만 보관할 수 있는 데이터 타입이다.  (카멜레온이라고 생각하면 됨..)

*** 공요체는 가변적으로 1개의 데이터만 보관할 수 있기 때문에 "공용체의 크기는 공용체의 데이터타입중 가장 큰것의 크기와 같다."

Ex)
    union one4all
    {
        int int_value;
        double double_value;
        string string_value;
    }

    int main()
    {
        one4all hi;             // 유니온 객체 hi 선언

        hi.int_value = 3;       // int_value 멤버에 3 대입   int형으로 쓰임

        hi.double_value = 3.14; // double_value에 3.14 대입  전에 대입되었던 int_value값은 사라진다.  ... 이런식으로 데이터를 한가지만 보관하고 있을 수 있다.  

        return 0;
    }



( 04.6 열거체 enum )

열거체 enum은 const를 사용하여 기호상수를 만드는 것에 대해 또다른 발판을 제공한다.

*** 또한 열거체는 산술연산자는 허용되지 않고, 대입연산자만 허용된다.   +- 불가능

    #include<iostream>

    using namespace std;

    enum Rainbow
    {                            enum멤버가 default 일경우 0부터 +1이 계속된다.
	    Red,                     // 0
	    Orange,                  // 1
	    Yellow = 123,            // *** 이런식으로 따로 초기화 할수도 있다. 123
	    Green,                   // *** 이후부턴 다시 +1 하여서 124
	    Blue,                    // 125
	    violet,                  // 126
	    ultraviolet              // 127
    };

    int main()
    {
	    Rainbow R;               // enum class Rainbow의 객체 R 선언
	    R = Yellow;              // *** enum객체에는 무조건 enum클래스의 멤버만 대입할 수 있다.


        // *** enum class의 대입 *** //
        
        int color = Red;         // *** enum class의 멤버들은 int형이므로 int형 변수에 넣을 수 있다.    enum 멤버 ---> int형 변수 (o)
        
        R = 3;                   // *** 역은 성립하지 않는다.  int value ---> enum 멤버 (x)

	    return 0;
    }


* 열거체의 값 범위
    
    #include<iostrea>

    enum bits {one=1, two=2, eight=8};       <--- *** enum의 값 범위를 구하는 것은 (P.178)

    int main()
    {
        bits my_bit;  // my_bit 선언
        
        my_bit = bits(6); // 대입   <--- *** 6의 값을 갖는 멤버는 없지만  맞다.  bits의 범위안에 6이 들어있기 때문이다.

        return 0;
    }




( 04.7 포인터와 메모리 해제 )

포인터란?   값자체가 아니라 값의 주소를 저장하는 '변수'이다.

동적할당?   일반적으로 배열을 선언할 경우, 컴파일타임의 배열의 크기를 결정해야 해서 몇개의 원소들이 들어올지 알 수 없기 때문에 배열을 크게잡아서 메모리가 낭비될 수 있다.  따라서, 런타임에 결정할 수 있는 new를 통해
           동적할당을 하게되면 메모리 낭비를 최소화 할 수 있다.


* 포인터의 선언과 초기화 
    
    포인터를 선언할 때에는 포인터가 지시하는 주소읙 값의 자료형을 서술해야 한다.  (왜냐하면 포인터 연산을 실행할 경우 *(ptr+1)에서의 +1은 데이터형에 따라서 값이 달라지기에 데이터형을 명시해야하는 것이다.)

    포인터는 말그대로 주소를 가지는 변수이기에  어떠한 자료형을 가르키는 포인터이던 크기는 같다. (주소를 가지고있는것이기 때문에 4/8bytes 로 모두 같음)

    (선언 형식) data_typeName* pointerName = value address;

    C++에서의 ptr = 0 은 널포인터를 의미한다.  즉, 널포인터는 아무주소도 가르키지 않는다는 의미이다.


* 포인터의 위험
    
    Ex) int* ptr;     // 만약 이렇게 ptr포인터를 초기화하지 않았을 경우,   ptr은 어느 랜덤한 쓰레기 주소를 가르키게된다.

        *ptr = 1004;  // 이후 *ptr를 통해 쓰레기주소에 1004를 대입하게 된다.    <--- 이러한 일이 발생되면 원래 쓰레기주소에 저장되어있던 값이 1004 로 바뀌는 등 찾기힘든 에러가 발생할 수 있다.



* 포인터의 수

    *** "포인터는 정수형이 아니다." 정수형과 다른 또다른 데이터다 (주소형이라고 생각하자)  Ex) int* ptr = 0xb83432; (x)   따라서 포인터에 직접적으로 16진수를 넣거나 할 수 없다.  주소형에 정수형을 넣는 꼴이므로

    *** 그러나, 정수형을 주소형으로 변경해준다면 대입이 가능하긴하다. Ex) int* ptr = (int*) 0xb83432; (o)   (int*)을 통해 정수형을 주소형으로 바꾸어주면 대입할 수는 있다.



* new를 통한 메모리 대입
    
    *** new연산자는 어떠한 데이터형의 메모리를 얼마나 원하는지 알려주면, 알아서 그에 알맞는 크기에 메모리블록을 찾고 그 메모리의 주소를 리턴한다.  이후 그 리턴된 주소를 포인터 변수에 저장해주면 된다.

    (형식) data_typeName* pointerName = new data_typeName [data count];

    *** new를 통해서 포인터에 대입하는 경우, 그 메모리에 접근하는 방법은 포인터 뿐이다.



* delete를 사용한 메모리 해제         *** delete는 new로 동적할당된 것에만 이용할 수 있는 것에 유의하자 ***

    delete는 사용하지 않게된 메모리를 다시 회수하는 역할을 한다.  이러한 기능덕에 C++는 메모리를 아주 효율적을오 관리할 수 있는 것이다.

    int* ptr = new int;

    delete ptr;         <--- *** delete ptr를 하게 되면 ptr이 가르키는 메모리를 삭제하게된다.   단, ptr포인터변수 자체는 계속 존재한다.



* new를 사용한 동적배열 생성

    *** 일반적으로 int arr[100]; 이런식의 컴파일 시간에 배열을 선언하게 된다면, 배열이 사옹되던 안되던 그 메모리를 항상 차기하게 되어 메모리가 효율적이지 못할 수 있다.  (정적바인딩)

    *** new를 통해 동적할당을 하게될 경우 int* arr = new int [N]; 프로그램실행시간에 배열의 크기를 결정할 수 있고, 필요없게되면 할당을 해제할 수 있어 메모리관리가 효율적이다. (동적바인딩)

    int num;
    
    cin >> num;

    int* arr = new int [num]; <--- *** 이런식으로 런타임에 받은 변수만큼 배열의 메모리를 동적으로 할당 할 수 있다.

    delete [] arr;            <--- *** new로 배열을 동적할당 하였을 경우 delete[]을 이용한다.


    ( 포인터의 사칙연산 )

    #include<iostream>

    using namespace std;

    int main()
    {
	    int *ptr = new int[10];

	    for (int i = 0; i < 10; ++i)
		    ptr[i] = i;                // ptr[0] 부터 0 1 2 3 4 5 6 7 8 9 이렇게 대입

	    ptr += 1;                      // *** 여기서 ptr = ptr + 1;  즉, int하나만큼 4byte만큼 포인터가 가르키는 주소를 이동시키게 된다.  따라서 ptr은 처음주소+4를 가르키게 됨
	
	    for (int i = 0; i < 9; ++i)
		    cout << ptr[i] << endl;    // *** 즉, 이제 여기서부터 ptr[0]은 (두번째원소) 1부터 시작하게 되는 것이다.     1 2 3 4 5 6 7 8 9

	    return 0;
    }




( 04.8 포인터, 배열, 포인터 연산 )

포인터연산은  일반적인 정수연산과 다르게  포인터에 -+1할때마다 포인터가 가르키는 자로의 자료형크기만큼 빼거나 더해진다.

포인터연산은 동적할당된배열 뿐아니라 일반적인 배열에서도 이용할 수 있다.  *** 또한 배열이름은 배열의 첫 원소의 주소를 의미한다.  int*ptr = arr; (o)  int*ptr = &arr[0]; (o)



* 배열의 주소 vs 배열의 첫원소 주소

    ****** 배열의 주소와  배열의 첫주소는 다른것 !!!  물론 가르키는 주소값은 갖지만, 포인터연산을 할때 얼마만큼씩 더해지고 빼지는지는 전혀 다르다. ******
    
   #include<iostream>

    using namespace std;

    int main()
    {
	    int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };  // 크기 40bytes

	    cout << arr << endl;      // 000000B08D0FF738   arr     즉, 배열의 첫원소 주소                                                                      
	    cout << &arr[0] << endl;  // 000000B08D0FF738   &arr[0] 즉, 배열의 첫원소 주소    
	    cout << &arr << endl;     // 000000B08D0FF738   &arr    즉, 배열의 주소           
	    
        cout << &arr + 1 << endl; // 000000B08D0FF760   &arr+1     *배열의 주소" +1 이기때문에 연산할때  +1 은 배열의 전체 사이즈를 의미하게 되므로, +40이 되버린다.  000000B08D0FF760

	    return 0;
    }

*** 또한 배열은 인자로 넘겨 줄때는 포인터로 넘겨주기 때문에 함수안에서 sizeof(arr)을 해보면 4가 출력된다. (포인터기에 4btyes)  따라서 함수에 배열을 보낼땐 배열의 길이도 같이 보내주어야 한다. ***



* 포인터와 문자열
    
    *** char형의 배열 이름, char형을 지시하는 포인터, 큰따음표로 쌓인 문자열 상수는 모두 문자열의 첫주소로 해석된다. ***  따라서 cout<<에 넣게되면 주소로 인식하고 '\0'을 만날때까지 출력함

    #include<iostream>

    using namespace std;

    int main()
    {
	    char ch[] = "hello world";           // ch[]배열이다  즉, h e l l o  w o r l d /0 가 들어가있게 된다.

        ***** 일단 알아 둘것은 cout은 매개변수로 char형을 지시하는 포인터변수를 사용할 수 있으며, '\0'을 만날때 까지 출력한다는 점이다.

	    cout << ch << endl;                  // hello world    ch는 ch배열의 첫주소를 의미하므로 첫주소부터 '\0'를 만날때까지 출력하여서
	
	    cout << ch + 1 << endl;              // ello world     ch+1은 2번째 주소부터므로

	    cout << &ch[1] << endl;              // ello world     &ch[1]도 2번째 주소므로

	    cout << &ch[1] + 1 << endl;          // llo world      2번째 +1  3번째 주소므로 

	    return 0;
    }



* new를 사용한 동적 구조체의 생성

    *** 일반 구조체에서는 '.'을 통해 멤버에 접근하지만, 동적할당된 구조체의 경우(포인터일때), 이름이 없기때문에(포인터로만 접근하기에) '.'을 이용할 수 없어서 '->'을 통해 접근한다. ***

    #include<iostream>

    using namespace std;

    struct threeN
    {
	    string Naver;
	    string Nexon;
	    string Ncsoft;
    };

    int main()
    {
	    threeN *it = new threeN;        // *** 구조체를 동적할당 한다.

        ******* 동적할당한 구조체는 "이름이 없기 때문에" (포인터로만 접근하기 때문에 동적할당된 것은) '.' 연산자를 사용할 수 없다.  따라서 멤버에 접근하기 위해선 '->' 연산자를 이용한다.
	    it->Naver = "네이버";
	    it->Nexon = "넥슨";
	    it->Ncsoft = "엔씨 소프트";

        *** 또다른 방법으론 *을 사용하는 방법이다.
        (*it).Naver;         <--- *it은 포인터가 가르키는 것이 되므로, 즉, threeN의 객체를 의미하게된다.  따라서 *it의 경우에는 '.'을 이용할 수 있다.

	    return 0;
    }





< 09 메모리 모델과 이름공간(namespace) >

( 09.1 분할 컴파일 )

C++는 프로그램을 구성하는 함수들을 나누어서 만들고, 링킹하는것을 허용한다.  만약 하나의 파일만 수정해야 한다면 그 파일만 다시 수정후 컴파일 하고 링킹하는 식으로 분할 컴파일이 가능하여서 대용량 프로그램을 만드는데 유리하다.

즉 대부분은 ide는 소스들의 수정시간을 추척하여서 변경된 소스들만 다시 컴파일하여서 링킹한다.

C++에서는 #include 라는 전처리기를 사용하여 헤더파일등을 적용할 수 있다.

이러한 기능을 제공하므로, 이런식으로 클래스, 함수코드 등을 헤더파일에 만들어서 하나의 패키지를 구성할 수 있다.  이것은 OOP의 특성에 매우 부합하는 점이다.

* 헤더파일에 넣는 것들
    함수원형    #define, const 정의하는 기호 상수    구조체 선언    클래스 선언    템플릿 선언    인라인 함수 등을 넣는다.    

* #include
    #include 에서  <>으로 묶여있으면 컴파일러는 표준헤더파일에서 찾고, " "으로 묶여있으면 소스디렉토리에서 찾게된다. (사용자가 만든 헤더파일을 include 할땐 " "을 이용한다.)



( 09.2 기억존속시간(namespace), 사용범위, 링크 )

C++는 네가지 유형으로 데이터를 저장한다.

{
    * 자동 기억 존속 시간
       
       함수나 블록안에 들어갈때 생성되고, 해당 함수나 블록을 떠날 때 해제된다.
        
       이렇게 자동적으로 생성/해제되는 것들을 "자동변수(지역변수)"라고 부른다.

        
        * 자동변수

        함수의 경우    아래의 함수가 있다고 가정하자.
            void print(int x)                      <--- 여기에서 인자로 들어온 x는 복사되어 들어온것이기에 변화가 되어도 메인함수에서의 x에는 아무런 영향을 끼치지 않는다.
            {                                           *** 여기에서의 x(인수)는 함수안에서만 유호하다.
                cout<< x <<endl;
            }


        블록의 경우
                int x;
            {
                int x;        <---- 여기서 선언된 x는 블록안에서만 유효하다.
            }

        

        * 자동변수와 스택
            
            새로 생기는 데이터는 먼저 생성된 데이터위에 쌓이고, 프로그램이 종료되면 데이터는 스택에서 제거된다. (자동변수도 마찬가지로 스택구조로 실행됨)

            프로그램은 두개의 포인터를 이용하여서 스택을 관리한다.   한포인터는 스택의 바닥(시작위치)의 주소를 가르키고, 다른 한 포인터는 다음 번 데이터를 저장할 (스택의 꼭대기) 빈곳의 주소를 가르킨다.

            
            (함수가 실행될때 어떻게 스택에 자동변수가 저장되고 해제되는지)
                
                1. 일단 스택에 한 포인터는 바닥을 가르키고, 다른 포인터는 빈 포인터를 가르키고 있다.

                2. 이후 함수가 실행되면 함수의 파라미터로 들어온 값들이 스택에 저장된다. 이후 다시 포인터는 움직여서 다음 빈 주소를 가르킨다.
                    
                    Ex) void print(int x, short y) {}                 
                        
                        위의 함수에서의 인자를 보면 int형 short형 두개가 들어오므로,  스택에 4,2 byte만큼의 메모리가 할당되고 스택에 저장된다.
                
                3. 함수종료 후, 포인터는 다시 처음 가르키던 위치로 돌아간다.(데이터들이 들어오기전 꼭대기를 가르킴)   *** 스택의 들어왔던 데이터는 사라지지 않음. 단, 포인터가 데이터가 들어가기전으로 돌아갔으므로
                                                                                                                   이후 다시 데이터가 스택으로 들어오면 다른값이 저장되므로 문제가 없다. (P.575)
          
          

                    
 
    * 정적 기억 존속 시간
        함수정의 바깥에서 정의된 변수 (main()함수 밖... ) 또는 static을 사용하여 정의된 변수등이 갖는것으로, 프로그램이 실행되는 전체시간에서 존속한다.
        

        * 정적변수          정적변수는 프로그램이 실행되는 전체시간동안 존속한다.  따라서 정적변수를 관리하는데 스택같은 장치가 필요가없다. 대신, 모든 정적변수를 수용할 수있는 메모리 블럭을 대입해준다.
        
            *** 정적변수가 초기화되지 않았다면 모든 비트가 0으로 세팅된다.   이것을 제로-초기화 (Zero-initialized)라고 한다.  <-- 일반변수와 다른점임. default initialization 이 있음

            (*** 정적변수의 종류 ***)

            1. 함수안에 있는 static
                
                void func()
                {
                    static int a = 0;     <--- *** 여기에 선언된 정적변수는 함수안에서만 사용할 수 있다. 단, 함수가 끝나도 메모리에 정적변수로써 값은 저장되어 있다.   
                    a ++ ;                <--- *** 즉, 다음에 이 함수안에서 a에 접근하면 1, 2, 3, 4, 5 이런식으로 흘러가게 된다. (값이 계속 저장되어있으므로)
                }
            

            2. 함수 외부에 static

                static int b = 1;         <--- *** 함수 외부의 정적변수는 이 파일에서는 모두 이용할 수 있다.

                int main()
                { ... }


            3. global
                
                전역변수는 main()함수 외부의 정의된 변수를 말한다.

                int g_value = 2;         <--- *** 이파일말고도 다른 파일에서도 접근할 수 있으며 끝까지 유지되는 변수이다.        (다른 파일에서 이용하게 될 경우 estern int g_value 이런식으로 선언후 사용한다.  (헷갈림을 방지하게위해 global인것을 알리기 위해)
                )

                int main()
                {}
                
                다른 파일에서 전역(global)변수를 사용할 경우
                
                extern int g_value;     g_value는 다른지역에서 정의되어있다는 의미
          
                

    * 쓰레드 존속 시간
    
    * 동적 기억 존속 시간
        new를 통한 동적할당된 메모리는 delete 또는 프로그램이 종료할 때 까지 존속한다.

        
        int *ptr = new int [10];     <--- new int [10]  40bytes를 메모리에 할당한다.

        delete[] ptr;                  <--- 할당한 40bytes를 메모리에서 제거한다.    *** 단, ptr 즉, 포인터변수는 선언되어있는 scope를 나가지 않는한 존재한다.   ptr에 또다른 메모리 주소를 대입할 수 있음
        (배열이 아닌 하나의 변수가 동적할당됬을땐  delete를 이용함)

        * new연산자를 이용한 초기화
            
            double *pi = new double (3.14);            <--- pi가 가르키는 곳에 3.14 double형 변수를 저장함

            
            struct st
            {
                int x;
                string name;
            };

            struct *st = new st {x_value,name_value};  <--- 이런식으로 new 연산자를 통해서 구조체도 초기화 할 수 있다.


        * 위치지정 new 연산자
            
            #include<iostream>
            #include<new>         <<< 위치지정 new연산자를 사용하기위해서 include

            using namespace std;

            struct st
            {
	            int x;
	            string name;
            };

            int main()
            {
	            char buffer1[50];
	            char buffer2[500];

	            st *s1;

	            int *int3;                        ***** 위치지정 new를 이용하는것은 자동변수들의 위치(힙x)에 메모리를 쓰기 때문에 동적할당이 아니다.   따라서 delete를 사용할 수 없다. ******

	            s1 = new(buffer1)st;               <--- buffer1배열의 위치에 메모리를 사용하여 st를 저장함

	            int3 = new(buffer2)int[20];        <--- buffer2배열의 위치에 메모리를 사용하여 int[20]만큼 저장함
	
	            cout << s1 <<" " <<&buffer1<< endl;        // 같다

	            cout << int3 << " " << &buffer2 << endl;   // 같다

	            return 0;
            }
}


* 제한자     (기억 공간 제한자)

    ( Cv-제한자 )
        cv는 const, volatile 을 말한다.    const는 한번 메모리에 초기화되면 그 메모리를 변경할 수 없다는 의미이다.    volatile는 프로그램코드가 변경하지 않더라도, 특정메모리의  값이 변경될 수 있다는 것이다. (Ex)하드웨어로 인한 메모리 수정등)
     

    static
    extern
    thread_local    <--- *** thread_local은 static 또는 extern과 함께 쓰일 수 있다.    thread_local은 변수 존속 시간을 쓰레드의 존속 시간과 같게 만든다.
    mutable         <--- *** const로 막힌 구조체(클래스)에서도 멤버를 mutable로 선언했다면 수정을 할 수 있다.
    
    Ex) mutable

        struct A
        {
            mutablee int x;
        };

        int main()
        {
            const A a;

            a.x=3;       <--- *** 분명 객체 a를 const로 고정했지만, a객체 내의 mutable변수는 수정을 할 수 있다.

            return 0;
        }


        tip) const로 전역변수를 막게되면,  전역변수임에도 불구하고, 그 파일 내에서만 이용이 가능하다. (const static처럼 쓰임)




( 09.3 이름공간(namespace))
    
    // 아래처럼 namespace을 이용하게 되면 같은 이름의 변수를 한 파일안에서 여러개를 사용할 수 있다.
    // A::x  B::x는 각각 다른 변수로 저장된다.

    #include<iostream>

    namespace A
    {
        int x;
        void func(){}
    }

    namespace B
    {
        int x;
        void func(){}
    }

    int main()
    {   
        A:: x = 1;   // namespace A의 x를 의미

        B:: x = 2;   // namespace B의 x를 의미

        return 0;
    }


    * using 선언과 using 지시자
        

        (using 선언)

        #include<iostream>

        namespace A
        {
            int x;
        }

        int main()        
        {
            using A::x;        <--- *** using namespace명:: 원하는데이터(or 함수등)      즉, 이 예제에서는 namespace A에 있는 x 변수를  main()함수에 알아서 추가하여 컴파일한다.  따라서 그냥 x를 통해서 접근이 가능해지는 것
                                    *** main()안에 x를 만드는것으로 작동하기 때문에 따로 main()함수에 x를 선언할 수 없게 된다는 점을 유의하자.
            int x = 3;         <--- *** 불가능함

            return 0;
        }



        (using 지시자)

        using namespace A;

        *** A안의 모든 변수, 함수등을 A:: 없이 사용할 수있음    namespace도 마찬가지로 A의 내부에 있는 것들을 main()함수에 추가하는 식으로 작동하기에  main()함수안에 namespace A의 변수, 함수와 같은 이름은 선언할 수 없다





< 10 객체와 클래스>

( 10.2 추상화 클래스 )

    * 접근제어
        
        * 데이터 은닉

            클래스에는 private public 이라는 키워드가 도입되었는데, 이 키워드들은 클래스멤버에 대한 접근제어를 서술하는 키워드들이다.

            public:  모든 프로그램의 부분에서 접근할 수 잇다.      private:  오직 그 클래스의 public메소드를 통해서만 접근할 수 있다. (우회해야함  직접접근이 불가능)

            이처럼 private등을 통해서 프로그램이 데이터에 직접 접근하지 못하게 하는것을 "데이터은닉"이라고 한다.  (데이터은닉은 데이터의 무결성을 높여주므로 좋은결과를 초래한다.)
        

        * public vs private

            일반적으로 데이터항목들은 private, 클래스인터페이스를 구성하는 멤버함수들은 public에 선언한다.

            물론 private에 멤버메소드를 넣거나  public에 데이터를 넣을 수 도 있다.


        * 클래스 멤버 함수의 구현
            
            대부분의 클래스메소드는 따로 정의한다.  매우 짧지 않은이상...

            class A
            {
            private:
                string name;

            public:
                void print();                    <--- 메소드를 선언만 할 경우
               
            };

            void A::print()                      <--- 이런식으로 외부에 클래스 메소드를 정의할 때에는 class명:: (namespace)을 붙어주어야 한다.   (이덕분에 함수 오버로딩이 가능한 것)
            {
                cout<< this->name << endl;
            }


        * 클래스 정리  *************** 클래스선언은 헤더파일에, 클래스 메소드의 정의는 따른 CPP파일에 정리

            < class headr.h> 

            class A
            {
            private:
                int m_num;

            public:
                A(){...}

                void print_num();    <--- 헤더에 선언한 메소드는 선언만
            };


            < class.cpp >

            #include"class headr.h"   <--- 선언이 있는 헤더를 include해줘야함

            void A::print_num()       <--- 내부에 선언만되있던 메소드를 정의해줌
            {
                cout<< this->name <<endl;
            }

                
            < main.cpp >

            #include "class headr.h "    <--- 헤더파일만 include하고

            int main()
            {
                A a;                 // 클래스를 사용할 수 있음
                
                a.print_num();       // 메소드도 사용가능

                return ;
            }


( 10.3 클래스 생성자 & 파괴자 )

    * 생성자

        *** 클래스의 경우 일반변수처럼 초기화가 불가능하다.  왜냐하면 int main()함수안에서는 클래스의 private 멤버변수들에게 접근권한이 없기 때문이다. 따라서 클래스는 멤버함수를 통해서 초기화를해야하는데

        *** 그것이바로 "생성자"이다.            생성자의 형태는 className() {} 의 형태이다.  (리턴형을 아예 갖지 않음)

    
    * 생성자 선언과 정의

        class people
        {
        private:
            string m_name;
            int m_age;

        public:
            people(string& name_in, int age_in = 5 )        <-- 생성자    int age_in = 5 처럼 인자의 default값을 설정할 수도 있다.
            {
                m_name = name_in;
                m_age = age_in;
            }
        
        }


    * 디폴트 생성자
    
        디폴트 생성자는  명시적인 초기화값을 제공하지 않을 경우 호출되는 생성자이다.  형식은 className() {}으로 아무것도 들어있지 않으며, 사용자가 생성자를 따로 생성하지 않았다면 타이핑하지않아도 자동으로 C++이
        
        객체를 생성할때 제공해준다.   만약 사용자가 따로 생성자를 생성했다면 디폴트 생성자는 C++에서 제공해주지 않는다.  따라서 사용자정의 생성자와 디폴트 생성자를 둘다 사용하고 싶을 경우 디폴트생성자를 따로

        타이핑 해주어야 한다.         즉, 생성자 또한 오버로딩이 가능하다는 것을 알 수 있다.


    * 파괴자
        
        객체의 수명이 끝나는 시점에 프로그램은 "파괴자"라는 멤버함수를 자동으로 호출한다.
        
        ~className() {} 의 형식을 갖으며  리턴형, 매개변수를 갖지 않는다.

    
    TIp) 객체는 서로 대입하는것이 가능하다 (대입연산자 오버로딩이 기본으로 되있음)


    * const 멤버함수           ( const객체는 const메소드만 이용할 수 있다. )

        class A
        {
        private:
            int m_num;

        public:
            void print()  
            {
                cout<< m_num <<endl;
            }
        };

        int main()
        {
            const A a;      <--- 객체를 const로 고정

            a.print();      <--- *** 오류가 나타남  분명 a는 const로 막아뒀지만,  print()함수는 안의 값을 바꾸는 함수가 아니기 때문에 호출이 가능할 것 같지만,  아니다.  객체를 const로 선언했다면  무조건 멤버함수도
                                 *** const로 막아져있는 함수만 사용할 수 있다.
            return 0;
        }

        
        즉,  void print() const      <--- 이렇게 멤버함수를 const로 막아줘야만 const로선언된 객체가 사용할 수 있다.
            {
                cout<< m_num <<endl;
            }   



( 10.4 this 포인터 )

    * this 포인터            <--- ***** this 포인터란  멤버함수를 호출하는데 사용된 객체의 주소값을 가진 포인터이다.  

        Ex) 더큰 객체를 리턴하는 메소드를 보자

        class A
        {
        private:
            int m_num;

        public:
            A& max(A& a)
            {
                if( (this->)m_num > a.m_num)
                    return *this;             <--- *this 포인터를 리턴  즉, 이 메소드를 호출한 객체의 주소를 포인터로 전달한다.   this는 호출한 객체의 주소를 갖고있는 포인터  *this는 객체  즉, 객체를 리턴함
                else
                    return a;
            }
        }




( 10.6 클래스 사용 범위 )

    클래스사용범위는 클래스안에서 정의되는 이름들에 적용된다.  * 무조건 클래스안에 정의된 멤버는 그 클래스 객체를 통해서만 호출이 가능하다.   * 클래스가 같아도 다른 객체 끼리의 메소드의 데이터는 완전히 다르다.

    * 클래스 사용 범위 상수

        class A
        {
        private:
            int m_x;
            static const int num=12;          <--- *** static const로 멤버변수를 선언하게 되면  만들어지는 모든 객체에서 같은 값을 갖게된다.

        public:

        };
 



< 11 클래스의 활용 >

( 11.1 연산자 오버로딩 )

opereator <-- 연산자 오버로딩을 하기 위한 연산자 함수      형식은   operator op () 

operator op ()는  앞에 객체를 임시적으로 사용하고 그안의 멤버 메소드로 op를 가져와서 사용한다.

Ex)  class A 안에  operator +() 이 오버로딩 되어있다고 가정하고 
     A a;
     B b;
 
     a+b; 를 하게되면    <--- *** a.operator + (b); 와 같이 작동한다. (a에서 operator+을 호출하고 인자로 b를 넣는 것처럼)





( 11.2 연산자오버로딩 예제 )

Ex)
     class A
    {
     public:
        int x;

       A operator + (A& a)                    <---- 이런식으로 클래스안에 operator오버로딩이 되어있을 경우 A&가 아닌 A로 리턴형을 사용해야한다 왜냐하면 이 예제에서는 result라는 클래스가 {} 안에서
       {                                            지역변수로 만들어지기 때문에 참조로보내면 지역변수므로 사라진후 참조가 불가능하기 때문이다.
            A result; 
                                                    *** 지역변수는 참조를 하면 안된다.
            result = x + a.x ;                      (부른객체의 x + a의 x)
            
            return result;
       }
    }




    연산자 오버로딩은 객체를 리턴할시 연쇄적으로 이용할 수 있다. chainning

    A t1,t2,t3;
       
    t1+t2+t3; 도 가능하다.   연쇄적으로 operator을 호출 할 수 있다.  t1+t2에서 A클래스인 객체를 리턴하므로 t1+t2리턴한객체에서 다시 operator을 호출하고 ... 연쇄적으로 가능



    연산자 오버로딩을 하게될 시  적어도 하나의 피연산자는 사용자 정의형 데이터형이어야 한다. (둘다 일반 데이터형이라면 오버로딩을 하지않고 그냥 일반 연산자 연산을 하게될테니까..)

    연산자의 우선순위 또한 변경할 수 없다.  + 보단 x 먼저..





( 11.3 프렌드의 도입 )

    프렌드는 프렌드함수, 프렌드 클래스, 프렌드 멤버함수의 형태로 쓰인다.

    함수를 어떤 클래스의 프렌드로 만들면, 그함수는 프렌드한 클래스와의 관계가 클래스와 클래스의멤버함수와의 관계와 같게된다. (*** 즉, private의 값에도 접근이 가능하게 된다.)

    특히 어떤 클래스의 이항연산자를 오버로딩을 할경우, friend를 만들 필요성이 많이 생긴다.

Ex) class A
    {
    private:
        int x;

    public:
        A operator *(double mult)
        {
            A result;
            result = x * mult;      (호출한 객체의 x값에 mult를 곱한다)

            return result;
        }
    }

    int main()
    {
        A a;

        a*3;    <--- 문제가 되지않는다.

        3*a;    <--- *** 이경우 문제가 된다.  3.operator *(a);는 불가능하기 때문이다. 3은객체가아니기때문     이렇게 연산을하는 자료형이 서로 다를 경우 문제점이 발생한다.  모든사람들에게 3*a대신 a*3이라고 쓰라고 할수도 없는 노릇이다

        return 0;
    }




* 프렌드 생성하기               위와같은 3*a 문제를 해결하기위해서 friend를 사용한다. friend가 하는기능은 여기서 크게 2가지이다.

    class A
    {
    private:
        int x;

    public:
        friend A operator *(double mult, A& a)      *** friend의 기능    1. operator *() 함수는 클래스안에 선언됬지만 "멤버함수가 아니라고 알린다."    2. operator *()를 멤버함수와 동등한 권한을 부여한다.
        {                                                                      
            A result;                                   friend를 붙여준 연산자오버로딩은 A:: 이런식의 namespace를 사용하지 않는다.(더이상 멤버함수가 아니기 때문)
            result = mult * a.x;

            return result;
        }
    }

    int main()
    {
        A a;
        A result;

        result = 2.7 * a;    <--- *** 이것이 가능하게 된다.  2.7.operator*()이 아닌  "일반함수"처럼 operator*(2.7, a); 실행되기 때문이다

        return 0;
    }




* 프렌드: << 연산자 오버로딩

    *** ostream 클래스안에는 cout객체가 있다. + ostream 클래스는 <<연산자를 오버로딩하여서 출력도구로 변환시킨다.

    즉, <<을 오버로딩하기위해서는 사용자정의클래스를 cout이 인식하도록  사용자정의클래스에 cout 사용법을 알려주는갓이 바람직한 방법이다.

    ***  <<연산자 오버로딩을 할때에도 마찬가지로 friend를 사용해야한다.  예시를 보면 이해하기 쉽다.

    Ex)  a라는 객체가 있다고 가정하자.  (a에는 <<가 오버로딩 되어있다)

        cout << a;     <--- *** 이것은 앞에서 본것처럼 cout.operator <<(a); 가 되버린다.  cout객체안에는 operator << 오버로딩이 없으므로 코드가 실행되지 않는다.  그렇다고해서 a << cout을 할수도 없지 않은가?

    *** 즉, cout << 에서도 friend를 사용하여서 멤버함수가아닌 일반함수로 사용해야 한다는 의미이다.                        
    
    
    즉, 프렌드를 사용하여 구현하면 이렇게 표현할 수 있다.
    class A
    {
    private:
        int x;
    
    public:
        friend ostream& operator << (ostream &os, A& a)            <--- *** 즉, operator << (cout, a); 처럼 이용된다는 것이다.   (일반함수이면서 + private에도 접근가능함)
        {                                                            operator << (ostream &os, A& a)  & 참조를 사용하는 이유는 os받고 또다시 os를 리턴하기 때문이다. 만약 os로 받고 다시 리턴한다면 복사값(지역변수)
            cout << a.x;                                             므로 다음에 참조가 되지않고 사라저버리기 때문이다.
            return os;                                      <--- *** ostream 객체를 참조로 리턴하기 때문에, cout << a << a ... <<을 연속적으로 호출할 수 있게된다.
        }                                                            계속해서 cout을 리턴하므로 연쇄적으로 호출이 가능함.
    }





( 11.4 오버로딩 연산자: 멤버함수와 멤버함수가 아닌 함수 )

    friend 멤버함수의 권한을 갖긴하나, 멤버함수가 아님.

    일반 operator overloading  멤버함수의 권한을 갖으며  멤버함수임.





( 11.6 자동변환과 클래스의 데이터형 변환 )

    * 아래의 예들은 대입되는 변수의 자료형에 맞게 들어가는 수의 자료형이 바뀐다.
    long l = 12;
    double d = 3;
    int i = 3.14;      <--- 단, 이런식으로 절삭이 일어날 수 있는 문제점이 있다.

    * 그러나 아래의 예와 같이 호환되지 않는 데이터형은 자동으로 변환하지 않는다.
    int *ptr = 10;     <--- 포인터는 주소를 받아야하므로, 10 정수를 받지 못한다.
                            int *ptr = (int*)10; 이런식으로 포인터로 명시적 형변환을 하여 대입을 할 순 있다.    (10이란 주소에 데이터가 있다면 읽어올 순 있음)  명시적 형변환은 자동으로 형변환이 안될 시 사용함



* 클래스의 자동 형변환 (묵시적 형변환)

    C++에서 하나의 매개변수만 취하는 클래스의 경우 자동적인 형변환이 가능합니다.

    class A
    {
    public:
        int x;

        A(int x_in)          <-- 하나의 매개변수만이 사용되는 생성자    << *** 변환생성자로 동작합니다. >>
            :x(x_in)
            {}
    }

    int main()
    {
        *** 원래같았다면 a.x = 3;   a.x = 14; 와 같이 바꾸어주어야하는데  클래스내의 매개변수가 "1개"라면 자동 형변환이 일어나   a(객체) = 3(정수) 의 대입이 가능하게 되는 것입니다. (변환생성자를 통해서 이루어짐)
        
        A a = 3;
        cout << a.x << endl;            <--- 3

        a = 14;
        cout << a.x << endl;            <--- 14 
    
        return 0;
    }



* Explicit을 통해 자동형변환 막기

    이러한 매개변수가 1개일 경우 변환생성자를 통해 자동 형변환이 되는 것을 막기 위해서 explicit을 사용할 수 있습니다.

    explicit A(int x_in)       <--- 이런식으로 변환생성자 앞에 explicit을 통해 막아주게 되면        A a = 13; 와 같은 자동적 형변환이 불가능하게 됩니다.
            :x(x_in)
            {}



* 변환 연산자     이번에는 객체 ---> 데이터형으로 변환하는 방법입니다.

    A a(5);

    int num = a;     <----는 컴파일에러가 발생합니다.   자동형변환이 불가능한  일반자로형 = 객체    일반자료형에 객체를 대입하기 때문입니다.

    이때 변환함수를 사용합니다.
    
    (변환함수)
    
    1. 변환함수는 메소드여야 합니다. (멤버함수여야함)                 operator typename()
    2. 변환함수는 리턴형이 없습니다.                                {
    3. 변환함수는 매개변수를 갖지 않습니다.                              return x;    // 형변환할 것                          
                                                                  }                                
                                
    class A
    {
    public:
        int x;

        A(int x_in)
        :x(x_in)
        {}

        operator int()    <--- *** 이때 이런식응로 변환함수를 작성하게 되면   일반자료형에 객체를 넣을 수 있습니다. (함수가 명시적 형변환을 해주게 됨)
        {
            return x;
        }
    }

    int main()
    {
        A a(5);
        
        int num = int(a);    <--- operator int()을 이용하여서 int형변수에 객체를 대입하는 것이 가능하다.          강제형변환

        int num = a;         <--- 이런식으로 int()를 생략하고 대입할 수 있다.    *** 이 경우 컴파일러가 알아서 변환함수가 있나 찾아보고 호출한다.

        return 0;
    }


    그런데 여기서도 실수의 여지가 있을 수 있다.  왜냐하면 변환함수의 경우에도 자동형변환이 일어날 수 있다는 점 때문이다.     원치않게 int num = a;와 같이 형변환이 자동으로 일어나 에러가 발생할 수 있기 때문이다.

    따라서  변환함수에도 C++는  explicit을 허용한다.



* Explicit 변환 함수
    
    class A
    {
        ...
        explicit operator int()    // *** explicit을 변환함수에 사용하게되면,  int num = a; 는 불가능해지고   int num = int(a); 이런식으로 명시적으로 코딩을 해주도록 된다.
        {
            return x;
        }    
    }

    int main()
    {
        A a(3);

        int num1 = a;       (x)  불가능

        int num2 = int(a);  (o) 가능

        return 0;
    }





< 12 클래스와 동적메모리 대입 >

( 12.1 동적 메모리와 클래스 )

    * static class 

        class stringss
        {
        private:
            static int num_string;
        
        public:
            stringss()
            {
                num_string++;    <-- 이런식으로 응용할 수 있다.
            }
       }

       int stringss:: num_string =1; *** 이런식으로 static변수를 외부에서 초기화 해주고 사용하면           static변수를 클래스 객체들이 같이 공유하는 변수로 사용할 수 있다.
                                     *** stataic변수를 그냥 상수로 사용할 것이라면, 클래스내에서 초기화해도 되지만,  변하는 공통변수로 쓰려면 외부에서 초기화해주어야한다.


   
    * 클래스내에서 동적할당시

       class A
       {
       private:
            char* str;

       public:
            A(const char* str)
            {
                str = new char [strlen(str)+1];       <---- 동적할당시
            }
        
            ~A()
            {
                delete [] str;                        <---- 파괴자에서 꼭 동적할당된 것을 delete해주어야한다.     파괴자는 객체를 제거하는것이지  클래스내에서 동적할당한 것은 따로 delete해주어야 한다. 
            }
       };


    * 복사생성자에서의 주의할점
        
        class A
        {
        private:
            int m_x;

        public:
            A()
            {
                cout<<"constructor"<<endl;
            }
        
        }

        void print(A a)
        {
            cout<<"hi"<<Endl;
        }

        int main()
        {
            A a;

            print(a);  <-- *** 여기서는 인수로 객체가 들어가게된다.  즉, 객체가 "복사해서 들어가게된다."    따라서, a가 들어갈때 복사생성자가 실행되게 된다. (*** 즉, 복사생성자로인해 복사한 객체가 1개더 만들어짐 )
                           *** 따라서 print(a); 가 실행될 때 복사셍성자가 실행되고, 이후 print(a);가 끝날때 "파괴자"가 실행된다.    따라서 분명 객체는 1개를 선언하였지만 파괴자는 2번이 실행되게 된다. 
            return 0;
        }


    * 특별 멤버 함수

        * 디폴트 생성자

            C++에서 제공하는 디폴트 생성자로 선언 안해도 생성되어있다.  따로 생성자를 선언했다면 사라지므로 다시 디폴트 생성자를 만들어 주어야 한다.
            
            또한, 디폴트 생성자는 클래스당 1개만 선언되어있어야 한다.


        * 복사 생성자

            *** 복사생성자는 일반적인 대입에 사용되는것이 아니라, 값 전달에 의한 함수 매개변수 전달을 포함한 초기화 작업에 사용된다.

            *** 형식은 className( const className& ); 이다.



            * 객체의 값으로써 전달과 래퍼런스로의 전달의 차이

                객체를 값응로 전달하나 래퍼런스로 전달하나 주소를 사용한다는 점에서 같으나,   값으로 전달시 복사생성자가 실행되고, "함수가 종료될때 파괴자가 실행된다"는 점이 다르다.  래퍼런스의 경우는 파괴자가 따로

                실행되지 않기 때문이다.     


            * 복사생성자는 언제 사용되는가?          복사생성자는 값으로 들어가는 객체에게 "주소"를 보내준다.
                
                새로운객체가 생성되어서 같은 종류의 기존객체로 초기화될때 호출된다.  예를 들어 새객체가 기존의 객체로 초기화 될때가 있다. 
                
                Ex) < 복사생성자 호출되는 경우 >  A newObject (oldObject);      A newObject = oldObject;      A*ptr = new A(oldObject);  <--- *** 이름없는 객체를 oldObject로 초기화하고 그 주소를 ptr로 넘김
                
                모든 복사생성자는 객체를 값으로 전달할때와, 객체를 값으로 리턴할때 실행된다.    즉, 객체를 전달할때에는 &참조를 통해 전달하는 것이 좋다 왜냐하면 값으로 전달할 경우 복사생성자가 실행되어서 퍼포먼스가

                저하될 수 있기 때문이다.


            * 복사생성자가 하는일은?

                디폴트 복사생성자는 복사생성자가 호출될 경우 멤버변수를 복사하여 전달한다. ( *** 단, static변수는 전달하지 않는다. ***)     <<< 복사생성자 != 생성자 >>> 복사생성자와 생성자는 전혀 다르다.

                *** static인수 또한 접근하는 복사생성자를 원한다면,  따로 복사생성자를 선언해주어야한다.  복사생성자 형식은 아래와 같다.

                className(const className& s)          // 사용자지정 복사생성자
                {
                    이안에서 필요한 static변수에 대해 코드를 적으면 된다.   나머지 멤버변수들은 알아서 복사되어 대입된다.
                }

                단, 복사생성자가 실행될 경우에 문제점이 있을 수 있다.    <--파괴자 때문이다.

                Ex)             ****************  복사생성자가 실행될때의 문제점  "동적할당되있던 값을 파괴자에서 삭제하도록 설계된 경우"

                class A
                {
                public:
                    char* str;

                public:
                    A(const char* str)
                    {
                        str = new char [strlen(str)+1];       // 생성자에서 동적할당함
                        str = *str;
                    }
                    
                    ~A()
                    {
                        delete[] str;                         // 파괴자에서 동적할당된 메모리를 회수한다. 
                    }
                };

                void print(A a)           <-- "값"으로 복사되어서 인수로 들어옴
                {
                    cout<<"hello"<<endl;
                };

                int main()
                {
                    A a;            <-- 여기서 객체가 생성된다   생성자가 실행되면서 str도 동적할당된 메모리의 주소가 들어가게 될것임

                    print(a);       <-- *** 여기서 a는 복사생성자를 통해서 값으로 복사되어 들어갈 것이고, "함수가 끝나는 시점에 복사되어서 들어온 복사객체a는 사라진다. 따라서 파괴자를 실행하고 동적할당이 해제된다"

                    cout<< a.str ;  <-- *** 이후 a의 동적할당되었던 값에대해 접근하면 오류가 발생한다.  앞에서 파괴자에 의해서 동적할당된 메모리가 해제되었기 때문에 이상한 값이 출력됨

                    return 0;
                }

                
                위와 같은 문제를 해결하기위해서 "명시적 복사 생성자를 사용한다"


        * 명시적 복사 생성자

                위와같은 클래스 설계상 문제점을 해결하는 방법은 "깊은 복사"를 이용하는 것이다.        즉 복사생성자가 문자열주소(래퍼런스)만 복사해가서 참조하는것이 아니라

                완전히 자체를 복사하고 그복사본을 대입하도록 하는 것이다.   이렇게 되면 복사생성자가 실행된 이후 파괴자가 실행되어 동적할당되었던 값들이 지워진다고 해도 원본의 메모리는 그대로 유지되기 따문이다.

                즉, 각각 복사생성자, 생성자가 따로따로 값을 갖도록한다는 의미이다. 이렇게 되면 서로다른 메모리를 해제하려하기 때문에 위와 같은 오류를 피할 수 있다.

                Ex)    명시적 복사 생성자 (깊은 복사)        명시적복사생성자를 선언할 경우 안에 모든 데이터가 들어가도록 해야함
                    
                    A (const A& a)
                    {
                        str = new char [strlen(a)+1];         <--- *** 이런식으로 복사생성자에서 객체 주소만 전달하는것이 아닌, 객체의 값들을 아예 복사하여서 따로 동적할당하여 저장한다.
                        str = a.*str;
                        num = a.num;
                        ....         // 이후 나머지 멤버 변수들을...
                        ...
       
                    }

                    ********* 즉, 동적할당되는 멤버변수들이 있다면 꼭! 따로 깊은 복사생성자를 선언해주어야 한다. ************


        
        * 클래스 대입연산자의 문제점

            클래스의 대입연산자 오버로딩은 이렇게 구현되어 있다.

                className& operator = (const className &);   
                
                *** 즉, 다른 클래스객체의 래퍼런스를 받아서 그 래퍼런스를 전달한다. 즉, 얕은복사가 일어나는것과 유사하다.  따라서 동적할당된 것의 경우 같은 주소를 가르키게됨



            A newObject = oldObject;           <-- *** 이 경우 oldObject를 복사하는 복사생성자가 실행된뒤에, 그 새로생성된 생성자가 newObject에 래퍼런스로 전달되게 된다.
                                                       따라서 이때에도, 만약동적할당된 멤버변수가 있다면 문제가 생긴다.  일단, 클래스객체는 지역변수이기 때문에 스택에 저장된다.
                                                       순서는 1. 복사생성자를 사용하여서 oldObject의 주소를 받아온 임시생성자 가 생성   2. 그 임시생성된 것을 =operator을 통해서 newObject란 새로운 객체에 복사한다.
                                                       3. 이후 수명이 끝나 사라질 때는 스택에 원리에 따라서 newObject가 파괴자를 실행하고, 복사생성자로 복사된 oldObject 파괴자가 실행된다.
                                                       둘의 객체들은 같은 동적할당 메모리의 주소를 가지고 있다는 문제점을 가지고 있고
                                                       위와같이 2번의 파괴자가 실행되게 되므로, 마지막 파괴자의 경우 지워져있는 메모리를 또 지우려고 할 것이다.  그리고 곧 이것은 어떠한 정보를 지울지
                                                       알 수 없는 큰 문제가 되는 것이다.


            * 클래스 대입연산자 문제점 해결

                대입연산자에서 얕은복사가 아닌 깊은복사를 하게 오버로딩해주면 된다!

                *** P.815




( 12.2 새롭게 개선된 string 클래스 )

    ....



( 12.3 생성자에 new를 사용할시 주의사항 )
    
    1. 생성자에서 동적할당을 할경우 꼭 파괴자에선 delete를 해주어야한다.
    
    2. 생성자는 여러개일 수 있으나 파괴자는 1개이다.  따라서 모든 생성자와 파괴자는 서로 합이 맞아야한다.
       파괴자에서 delete 를 사용한다면 모든 생성자에서는 동적할당시 1개만 해야할 것이고,  파괴자에서 delete[]을 사용한다면 모든 생성자에서는 동적할당시 배열을 할당해야 할 것이다.





( 12.4 객체리턴에 대한 관찰 )

    

    


