< 11 클래스의 활용 >

( 11.1 연산자 오버로딩 )

opereator <-- 연산자 오버로딩을 하기 위한 연산자 함수      형식은   operator op () 

operator op ()는  앞에 객체를 임시적으로 사용하고 그안의 멤버 메소드로 op를 가져와서 사용한다.

Ex)  class A 안에  operator +() 이 오버로딩 되어있다고 가정하고 
     A a;
     B b;
 
     a+b; 를 하게되면    <--- *** a.operator + (b); 와 같이 작동한다. (a에서 operator+을 호출하고 인자로 b를 넣는 것처럼)





( 11.2 연산자오버로딩 예제 )

Ex)
     class A
    {
     public:
        int x;

       A operator + (A& a)                    <---- 이런식으로 클래스안에 operator오버로딩이 되어있을 경우 A&가 아닌 A로 리턴형을 사용해야한다 왜냐하면 이 예제에서는 result라는 클래스가 {} 안에서
       {                                            지역변수로 만들어지기 때문에 참조로보내면 지역변수므로 사라진후 참조가 불가능하기 때문이다.
            A result; 
                                                    *** 지역변수는 참조를 하면 안된다.
            result = x + a.x ;                      (부른객체의 x + a의 x)
            
            return result;
       }
    }




    연산자 오버로딩은 객체를 리턴할시 연쇄적으로 이용할 수 있다. chainning

    A t1,t2,t3;
       
    t1+t2+t3; 도 가능하다.   연쇄적으로 operator을 호출 할 수 있다.  t1+t2에서 A클래스인 객체를 리턴하므로 t1+t2리턴한객체에서 다시 operator을 호출하고 ... 연쇄적으로 가능



    연산자 오버로딩을 하게될 시  적어도 하나의 피연산자는 사용자 정의형 데이터형이어야 한다. (둘다 일반 데이터형이라면 오버로딩을 하지않고 그냥 일반 연산자 연산을 하게될테니까..)

    연산자의 우선순위 또한 변경할 수 없다.  + 보단 x 먼저..





( 11.3 프렌드의 도입 )

    프렌드는 프렌드함수, 프렌드 클래스, 프렌드 멤버함수의 형태로 쓰인다.

    함수를 어떤 클래스의 프렌드로 만들면, 그함수는 프렌드한 클래스와의 관계가 클래스와 클래스의멤버함수와의 관계와 같게된다. (*** 즉, private의 값에도 접근이 가능하게 된다.)

    특히 어떤 클래스의 이항연산자를 오버로딩을 할경우, friend를 만들 필요성이 많이 생긴다.

Ex) class A
    {
    private:
        int x;

    public:
        A operator *(double mult)
        {
            A result;
            result = x * mult;      (호출한 객체의 x값에 mult를 곱한다)

            return result;
        }
    }

    int main()
    {
        A a;

        a*3;    <--- 문제가 되지않는다.

        3*a;    <--- *** 이경우 문제가 된다.  3.operator *(a);는 불가능하기 때문이다. 3은객체가아니기때문     이렇게 연산을하는 자료형이 서로 다를 경우 문제점이 발생한다.  모든사람들에게 3*a대신 a*3이라고 쓰라고 할수도 없는 노릇이다

        return 0;
    }




* 프렌드 생성하기               위와같은 3*a 문제를 해결하기위해서 friend를 사용한다. friend가 하는기능은 여기서 크게 2가지이다.

    class A
    {
    private:
        int x;

    public:
        friend A operator *(double mult, A& a)      *** friend의 기능    1. operator *() 함수는 클래스안에 선언됬지만 "멤버함수가 아니라고 알린다."    2. operator *()를 멤버함수와 동등한 권한을 부여한다.
        {                                                                      
            A result;                                   friend를 붙여준 연산자오버로딩은 A:: 이런식의 namespace를 사용하지 않는다.(더이상 멤버함수가 아니기 때문)
            result = mult * a.x;

            return result;
        }
    }

    int main()
    {
        A a;
        A result;

        result = 2.7 * a;    <--- *** 이것이 가능하게 된다.  2.7.operator*()이 아닌  "일반함수"처럼 operator*(2.7, a); 실행되기 때문이다

        return 0;
    }




* 프렌드: << 연산자 오버로딩

    *** ostream 클래스안에는 cout객체가 있다. + ostream 클래스는 <<연산자를 오버로딩하여서 출력도구로 변환시킨다.

    즉, <<을 오버로딩하기위해서는 사용자정의클래스를 cout이 인식하도록  사용자정의클래스에 cout 사용법을 알려주는갓이 바람직한 방법이다.

    ***  <<연산자 오버로딩을 할때에도 마찬가지로 friend를 사용해야한다.  예시를 보면 이해하기 쉽다.

    Ex)  a라는 객체가 있다고 가정하자.  (a에는 <<가 오버로딩 되어있다)

        cout << a;     <--- *** 이것은 앞에서 본것처럼 cout.operator <<(a); 가 되버린다.  cout객체안에는 operator << 가 없으므로 코드가 실행되지 않는다.  그렇다고해서 a << cout을 할수도 없지 않은가?

    *** 즉, cout << 에서도 friend를 사용하여서 멤버함수가아닌 일반함수로 사용해야 한다는 의미이다.                        
    
    
    즉, 프렌드를 사용하여 구현하면 이렇게 표현할 수 있다.
    class A
    {
    private:
        int x;
    
    public:
        ostream& operator << (ostream &os, A& a)            <--- *** 즉, operator << (cout, a); 처럼 이용된다는 것이다.   (일반함수이면서 + private에도 접근가능함)
        {                                                            operator << (ostream &os, A& a)  & 참조를 사용하는 이유는 os받고 또다시 os를 리턴하기 때문이다. 만약 os로 받고 다시 리턴한다면 복사값(지역변수)
            cout << a.x;                                             므로 다음에 참조가 되지않고 사라저버리기 때문이다.
            return os;                                      <--- *** ostream 객체를 참조로 리턴하기 때문에, cout << a << a ... <<을 연속적으로 호출할 수 있게된다.
        }                                                            계속해서 cout을 리턴하므로 연쇄적으로 호출이 가능함.
    }
